<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<!-- Для мобильных устройств -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>glTF: камера, свет и переход к контенту</title>
	<style>
		body {
			margin: 0;
			overflow-x: hidden;
			font-family: sans-serif;
		}

		/* Первая секция: анимация с 3D-сценой */
		#canvas-section {
			position: relative;
			width: 100%;
			height: 100vh;
			overflow: hidden;
		}

		/* Контейнер для канвы */
		#canvas-container {
			width: 100%;
			height: 100%;
		}

		/* Оверлей для затемнения – изначально прозрачный */
		#overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: black;
			opacity: 0;
			pointer-events: none;
			z-index: 10;
		}

		/* Вторая секция: контент */
		.content-section {
			width: 100%;
			height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;
			background: #f0f0f0;
			font-size: 2em;
		}
	</style>
	<!-- Подключаем библиотеки -->
	<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
	<!-- Если модель использует Draco-сжатие -->
	<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/ScrollTrigger.min.js"></script>
</head>

<body>
	<!-- Первая секция: 3D-анимация с затемнением -->
	<section id="canvas-section">
		<div id="canvas-container"></div>
		<div id="overlay"></div>
	</section>
	<!-- Вторая секция: контент -->
	<section class="content-section">
		<p>Контент следующей секции. Здесь может быть текст, изображения и т.д.</p>
	</section>
	<script>
		document.addEventListener('DOMContentLoaded', () => {
			const scene = new THREE.Scene();

			// Создаем рендерер и добавляем его в контейнер
			const renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('canvas-container').appendChild(renderer.domElement);

			// Настраиваем GLTFLoader и DRACOLoader
			const loader = new THREE.GLTFLoader();
			const dracoLoader = new THREE.DRACOLoader();
			dracoLoader.setDecoderPath('https://unpkg.com/three@0.128.0/examples/js/libs/draco/gltf/');
			loader.setDRACOLoader(dracoLoader);

			let microscope; // Объект модели
			let embeddedCamera; // Камера из glTF или запасная

			loader.setPath('scope/');
			loader.load('scope.gltf', (gltf) => {
				// Вывод информации о текстурах (для проверки)
				gltf.scene.traverse(child => {
					if (child.isMesh) {
						const material = child.material;
						if (material.map) {
							console.log(`У меша ${child.name} есть базовая текстура (map)`);
						} else {
							console.log(`У меша ${child.name} базовая текстура отсутствует`);
						}
						if (material.normalMap) console.log(`У меша ${child.name} есть normalMap`);
						if (material.roughnessMap) console.log(`У меша ${child.name} есть roughnessMap`);
						if (material.metalnessMap) console.log(`У меша ${child.name} есть metalnessMap`);
					}
				});


				microscope = gltf.scene;
				scene.add(microscope);

				// Пытаемся получить встроенную камеру
				if (gltf.cameras && gltf.cameras.length > 0) {
					embeddedCamera = gltf.cameras[0];
				} else {
					gltf.scene.traverse(child => {
						if (child instanceof THREE.Camera) {
							embeddedCamera = child;
						}
					});
				}
				if (!embeddedCamera) {
					console.warn("Встроенная камера не найдена, создается запасная.");
					embeddedCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					embeddedCamera.position.set(0, 2, 5);
				}
				scene.add(embeddedCamera);

				// Обработка света: если данные KHR_lights_punctual есть, создаем свет на их основе.
				const json = gltf.parser.json;
				if (json.extensions && json.extensions.KHR_lights_punctual) {
					const lightsDefs = json.extensions.KHR_lights_punctual.lights;
					lightsDefs.forEach((lightDef, index) => {
						let light;
						const color = new THREE.Color().fromArray(lightDef.color || [1, 1, 1]);
						const intensity = (lightDef.intensity !== undefined ? lightDef.intensity : 1) * 0.5;
						switch (lightDef.type) {
							case 'directional':
								light = new THREE.DirectionalLight(color, intensity);
								break;
							case 'point':
								light = new THREE.PointLight(color, intensity);
								break;
							case 'spot':
								light = new THREE.SpotLight(color, intensity);
								if (lightDef.spot) {
									light.angle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4;
									light.penumbra = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
								}
								break;
							default:
								console.warn("Неизвестный тип света:", lightDef.type);
						}
						if (light) {
							// Если позиционирования нет, задаем вручную (подберите значения)
							light.position.set(0, 5 + index * 2, 5);
							scene.add(light);
						}
					});
				} else {
					console.warn("Данные о свете (KHR_lights_punctual) не найдены.");
				}

				// Сохраняем исходное положение камеры (как экспортирована)
				const initialCameraPos = embeddedCamera.position.clone();
				// Задаем конечное положение камеры вручную (укажите нужные координаты)
				const finalCameraPos = new THREE.Vector3(1, 1, 3);

				// Регистрируем ScrollTrigger с pin для первой секции
				gsap.registerPlugin(ScrollTrigger);
				ScrollTrigger.create({
					trigger: "#canvas-section",
					start: "top top",
					end: "+=1000", // расстояние прокрутки для завершения анимации (настраиваемое значение)
					scrub: true,
					pin: true,
					onUpdate: self => {
						// Интерполируем позицию камеры
						embeddedCamera.position.lerpVectors(initialCameraPos, finalCameraPos, self.progress);
						embeddedCamera.lookAt(0, 0, 0);
						// Пример трансформации объекта: поворот по оси Y до 45°
						microscope.rotation.y = self.progress * (Math.PI / 4);
						// Затемнение: когда анимация почти завершена, плавно увеличиваем opacity оверлея
						if (self.progress > 0.9) {
							let fadeProgress = (self.progress - 0.9) / 0.1; // от 0 до 1
							document.getElementById("overlay").style.opacity = fadeProgress;
						} else {
							document.getElementById("overlay").style.opacity = 0;
						}
					}
				});

				animate();
			}, undefined, (error) => {
				console.error("Ошибка загрузки модели:", error);
			});

			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, embeddedCamera);
			}

			window.addEventListener('resize', () => {
				embeddedCamera.aspect = window.innerWidth / window.innerHeight;
				embeddedCamera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		});
	</script>
</body>

</html>