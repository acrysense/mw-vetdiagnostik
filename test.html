<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<!-- Для мобильных устройств -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Проверка текстур и материалов</title>
	<style>
		body {
			margin: 0;
			overflow-x: hidden;
		}

		#canvas-container {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		.scroll-container {
			height: 200vh;
		}
	</style>
	<!-- Подключаем библиотеки -->
	<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
	<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/ScrollTrigger.min.js"></script>
</head>

<body>
	<div id="canvas-container"></div>
	<div class="scroll-container"></div>
	<script>
		document.addEventListener('DOMContentLoaded', () => {
			const scene = new THREE.Scene();

			// Создаем рендерер
			const renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			// Важно для корректного отображения цветов текстур
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1.0; // можно немного корректировать

			const testAmbient = new THREE.AmbientLight(0xffffff, 1);
			scene.add(testAmbient);


			document.getElementById('canvas-container').appendChild(renderer.domElement);

			// Настраиваем GLTFLoader и DRACOLoader
			const loader = new THREE.GLTFLoader();
			loader.setPath('scope/'); // базовый путь к файлам (scope.gltf, scope.bin, текстуры)
			const dracoLoader = new THREE.DRACOLoader();
			dracoLoader.setDecoderPath('https://unpkg.com/three@0.128.0/examples/js/libs/draco/gltf/');
			loader.setDRACOLoader(dracoLoader);

			let microscope, embeddedCamera;

			loader.load('scope2.glb', (gltf) => {
				microscope = gltf.scene;
				scene.add(microscope);
				microscope.traverse(child => {
					if (child.isMesh && child.material) {
						if (child.material.map) {
							child.material.map.encoding = THREE.sRGBEncoding;
							child.material.needsUpdate = true;
						}
					}
				});


				// Вывод информации о текстурах для отладки
				// Проверяем каждый меш в модели
				microscope.traverse(child => {
					if (child.isMesh && child.material) {
						// Проверяем наличие базовой текстуры
						if (child.material.map) {
							console.log(`Меш ${child.name}: базовая текстура найдена`);
							// Выводим объект изображения текстуры
							console.log(`Texture image for ${child.name}:`, child.material.map.image);
							// Если изображение уже загружено, можно вывести его размеры (если доступны)
							if (child.material.map.image && child.material.map.image.width) {
								console.log(`Размеры текстуры ${child.name}: ${child.material.map.image.width}x${child.material.map.image.height}`);
							}
							// Устанавливаем кодирование для корректного отображения
							child.material.map.encoding = THREE.sRGBEncoding;
						} else {
							console.warn(`Меш ${child.name}: базовая текстура отсутствует`);
						}

						// Проверяем, установлены ли UV-координаты
						if (child.geometry && !child.geometry.attributes.uv) {
							console.warn(`Меш ${child.name} не содержит UV-координат!`);
						}

						// Для проверки установим базовый цвет материала в белый
						if (child.material.color) {
							child.material.color.set(0xffffff);
						}
						child.material.needsUpdate = true;
					}
				});



				// Пытаемся получить встроенную камеру
				if (gltf.cameras && gltf.cameras.length > 0) {
					embeddedCamera = gltf.cameras[0];
				} else {
					gltf.scene.traverse(child => {
						if (child instanceof THREE.Camera) {
							embeddedCamera = child;
						}
					});
				}
				if (!embeddedCamera) {
					console.warn("Встроенная камера не найдена, создается запасная.");
					embeddedCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					embeddedCamera.position.set(0, 2, 5);
				}
				scene.add(embeddedCamera);

				// Обработка света (оставляем ваш код для света)
				const json = gltf.parser.json;
				if (json.extensions && json.extensions.KHR_lights_punctual) {
					const lightsDefs = json.extensions.KHR_lights_punctual.lights;
					lightsDefs.forEach((lightDef, index) => {
						let light;
						const color = new THREE.Color().fromArray(lightDef.color || [1, 1, 1]);
						const intensity = (lightDef.intensity !== undefined ? lightDef.intensity : 1) * 0.5;
						switch (lightDef.type) {
							case 'directional':
								light = new THREE.DirectionalLight(color, intensity);
								break;
							case 'point':
								light = new THREE.PointLight(color, intensity);
								break;
							case 'spot':
								light = new THREE.SpotLight(color, intensity);
								if (lightDef.spot) {
									light.angle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4;
									light.penumbra = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
								}
								break;
							default:
								console.warn("Неизвестный тип света:", lightDef.type);
						}
						if (light) {
							light.position.set(0, 5 + index * 2, 5);
							scene.add(light);
						}
					});
				} else {
					console.warn("Данные о свете (KHR_lights_punctual) не найдены.");
				}

				// Дальнейшая анимация (камеры, скролл и т.д.)
				const initialCameraPos = embeddedCamera.position.clone();
				const finalCameraPos = new THREE.Vector3(1, 1, 3);

				gsap.registerPlugin(ScrollTrigger);
				ScrollTrigger.create({
					trigger: ".scroll-container",
					start: "top top",
					end: "bottom bottom",
					scrub: true,
					onUpdate: self => {
						embeddedCamera.position.lerpVectors(initialCameraPos, finalCameraPos, self.progress);
						embeddedCamera.lookAt(0, 0, 0);
						microscope.rotation.y = self.progress * (Math.PI / 4);
					}
				});

				animate();
			}, undefined, (error) => {
				console.error("Ошибка загрузки модели:", error);
			});

			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, embeddedCamera);
			}

			window.addEventListener('resize', () => {
				embeddedCamera.aspect = window.innerWidth / window.innerHeight;
				embeddedCamera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		});
	</script>
</body>

</html>