"use strict";

document.addEventListener('DOMContentLoaded', function () {
  // Initialize a new Lenis instance for smooth scrolling
  // const lenis = new Lenis({
  //     lerp: 0.15,
  //     smooth: true
  // })

  // function raf(time) {
  //     lenis.raf(time)
  //     requestAnimationFrame(raf)
  // }

  // requestAnimationFrame(raf)

  var horizontalContent = document.querySelector('.footer-nav__list');
  var sectionWidth = horizontalContent.scrollWidth;
  var windowWidth = window.innerWidth;
  var windowHeight = window.innerHeight;
  var offset = 200; // Начальное смещение, чтобы видеть первый пункт
  var startOffset = 0; // Начальный порог прокрутки

  var isInView = false; // Флаг для отслеживания видимости блока
  var startScrollY = 0; // Переменная для отслеживания начальной позиции блока

  // Используем Intersection Observer для отслеживания появления блока в области видимости
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (entry.isIntersecting) {
        isInView = true;
        startScrollY = window.scrollY; // Запоминаем начальную позицию скролла
      } else {
        isInView = false;
      }
    });
  }, {
    threshold: 0.1
  });
  observer.observe(horizontalContent);
  var lenis = new Lenis({
    lerp: 0.15,
    smooth: true
  });
  function raf(time) {
    lenis.raf(time);
    requestAnimationFrame(raf);
  }
  requestAnimationFrame(raf);
  lenis.on('scroll', function () {
    if (!isInView) return; // Если блок не в видимости, не запускаем прокрутку

    var scrollProgress = lenis.scroll; // Получаем текущую прокрутку из Lenis
    var maxScroll = document.documentElement.scrollHeight - windowHeight; // Максимальная прокрутка
    var scrollRatio = scrollProgress / maxScroll; // Пропорция прокрутки

    // Корректируем движение по оси X с учетом ширины контента и окна
    var moveX = -(sectionWidth - windowWidth) * scrollRatio + startOffset;

    // Ограничиваем движение, чтобы последний пункт не выходил за пределы видимости
    if (moveX > 0) {
      moveX = 0; // Не разрешаем двигаться вправо за пределы
    } else if (moveX < -(sectionWidth - windowWidth)) {
      moveX = -(sectionWidth - windowWidth); // Не разрешаем двигаться влево за пределы
    }

    // Применяем смещение для движения
    horizontalContent.style.transform = "translateX(".concat(moveX, "px)");
  });

  // function's
  function bodyFixScroll(status) {
    var scrollPosition = 0;
    var paddingOffset = window.innerWidth - document.body.offsetWidth + 'px';
    var elementsFixed = document.querySelectorAll('.fixed');
    if (status) {
      document.body.classList.add('scroll-disabled');
      scrollPosition = window.pageYOffset;
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      if (document.body.style.top) {
        document.body.style.top = document.body.style.top;
      } else {
        document.body.style.top = '-' + scrollPosition + 'px';
      }
      document.body.style.width = '100%';
      document.body.style.paddingRight = paddingOffset;
      if (elementsFixed) {
        elementsFixed.forEach(function (item) {
          item.style.marginRight = paddingOffset;
        });
      }
    } else {
      document.body.classList.remove('scroll-disabled');
      scrollPosition = Math.abs(parseInt(document.querySelector('body').style.top.replace('px', '')));
      document.body.style.removeProperty('overflow');
      document.body.style.removeProperty('position');
      document.body.style.removeProperty('top');
      document.body.style.removeProperty('width');
      document.body.style.removeProperty('padding-right');
      if (elementsFixed) {
        elementsFixed.forEach(function (item) {
          item.style.removeProperty('margin-right');
        });
      }
      window.scrollTo({
        top: !isNaN(scrollPosition) ? scrollPosition : 0,
        behavior: 'instant'
      });
    }
  }

  // checker
  var useItemChecker = function useItemChecker(els, onClickOutside) {
    var checkBodyClick = function checkBodyClick(e) {
      var currentEl = e.target;
      while (currentEl) {
        if (els.includes(currentEl)) break;
        currentEl = currentEl.parentNode;
      }
      if (!currentEl) {
        onClickOutside();
        removeBodyChecker();
      }
    };
    function setBodyChecker() {
      document.documentElement.addEventListener('click', checkBodyClick);
    }
    function removeBodyChecker() {
      document.documentElement.removeEventListener('click', checkBodyClick);
    }
    return {
      setBodyChecker: setBodyChecker,
      removeBodyChecker: removeBodyChecker
    };
  };

  // inputmask
  Inputmask().mask(document.querySelectorAll('input'));

  // textarea
  var allTexareas = document.querySelectorAll('textarea');
  if (allTexareas) {
    allTexareas.forEach(function (el) {
      el.style.height = el.setAttribute('style', 'height: ' + el.scrollHeight + 'px');
      el.classList.add('auto');
      el.addEventListener('input', function (e) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
      });
    });
  }

  // research
  var researchCards = document.querySelectorAll('.research-card');
  var body = document.body;
  if (researchCards) {
    researchCards.forEach(function (card) {
      card.addEventListener('mouseenter', function () {
        var bgColor = card.getAttribute('data-bg-color');
        body.style.backgroundColor = bgColor;
        researchCards.forEach(function (otherCard) {
          if (otherCard !== card) {
            otherCard.classList.add('is--dimmed');
          }
        });
      });
      card.addEventListener('mouseleave', function () {
        body.style.backgroundColor = '#1E2C48';
        researchCards.forEach(function (otherCard) {
          otherCard.classList.remove('is--dimmed');
        });
      });
    });
  }

  // heart
  var heartBtn = document.querySelectorAll('.c-heart__btn');
  if (heartBtn) {
    heartBtn.forEach(function (item) {
      item.addEventListener('click', function (event) {
        event.preventDefault();
        if (item.classList.contains('is--active')) {
          item.classList.remove('is--active');
        } else {
          item.classList.add('is--active');
        }
      });
    });
  }
});